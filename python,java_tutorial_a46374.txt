# Python Tutorial: Basic Data Aggregation with Pandas

# Learning Objective:
# This tutorial will introduce you to the fundamental concept of data aggregation
# using the pandas library in Python. We'll learn how to group data by specific
# criteria and then calculate summary statistics (like sum, average, and count)
# for those groups. This is a crucial skill for understanding patterns and
# extracting insights from your datasets.

# We'll be using the pandas library, which is a powerful tool for data manipulation
# and analysis in Python. If you don't have it installed, you can install it
# using pip: pip install pandas

import pandas as pd

def analyze_sales_data(data):
    """
    Analyzes sales data to aggregate sales by product category.

    Args:
        data (pd.DataFrame): A pandas DataFrame containing sales information.
                             Expected columns: 'Product', 'Category', 'Sales'.

    Returns:
        pd.DataFrame: A DataFrame showing the total sales for each category.
    """
    # We're creating a DataFrame from a dictionary.
    # In a real-world scenario, you'd likely load this from a CSV or database.
    # This dictionary represents our sample sales data.
    sales_df = pd.DataFrame(data)

    # The core of our aggregation happens here.
    # The .groupby() method allows us to split the DataFrame into groups
    # based on the values in one or more columns.
    # Here, we group by the 'Category' column.
    grouped_data = sales_df.groupby('Category')

    # Now that we have our groups, we want to perform an aggregation.
    # The .agg() method lets us apply multiple aggregation functions to our groups.
    # We want to calculate the sum of 'Sales' for each 'Category'.
    # The syntax {column_to_aggregate: aggregation_function} is used.
    aggregated_sales = grouped_data.agg(
        Total_Sales=('Sales', 'sum'),  # Calculate the sum of 'Sales' and name it 'Total_Sales'
        Average_Sales=('Sales', 'mean'), # Calculate the average of 'Sales' and name it 'Average_Sales'
        Number_of_Sales=('Sales', 'count') # Count the number of sales entries for each category
    )

    # The result is a new DataFrame where the index is the 'Category' and
    # the columns are our aggregated statistics.
    return aggregated_sales

# --- Example Usage ---

# Let's define our sample data.
# This is a dictionary where keys are column names and values are lists of data.
sample_sales_data = {
    'Product': ['Laptop', 'Mouse', 'Keyboard', 'Monitor', 'Webcam', 'Desk', 'Chair', 'Lamp'],
    'Category': ['Electronics', 'Electronics', 'Electronics', 'Electronics', 'Electronics', 'Furniture', 'Furniture', 'Furniture'],
    'Sales': [1200, 25, 75, 300, 50, 150, 80, 40]
}

# Now, let's call our analysis function with this data.
analysis_result = analyze_sales_data(sample_sales_data)

# Finally, we print the results to see the aggregated sales by category.
# This will show us how much was sold, the average sale value, and how many
# sales occurred within each product category.
print("--- Sales Analysis Results ---")
print(analysis_result)
print("\n--- Explanation of Results ---")
print("The table above shows: ")
print("- Total_Sales: The sum of all sales for products within that category.")
print("- Average_Sales: The average sale value for products within that category.")
print("- Number_of_Sales: The total number of individual sales transactions for that category.")
print("This allows for quick insights into which categories are performing best.")


# --- End of Tutorial ---
```

# Java Tutorial: Basic Data Aggregation with Streams

# Learning Objective:
# This tutorial will introduce you to the fundamental concept of data aggregation
# in Java using the Stream API. We'll learn how to group data by specific
# criteria and then calculate summary statistics (like sum, average, and count)
# for those groups. This is a crucial skill for understanding patterns and
# extracting insights from your datasets.

# We'll be using Java's Stream API, which provides a functional approach to
# processing collections.

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

// We'll define a simple class to represent our sales data.
class Sale {
    String product;
    String category;
    double sales;

    // Constructor to easily create Sale objects.
    public Sale(String product, String category, double sales) {
        this.product = product;
        this.category = category;
        this.sales = sales;
    }

    // Getters are good practice for accessing class fields.
    public String getProduct() {
        return product;
    }

    public String getCategory() {
        return category;
    }

    public double getSales() {
        return sales;
    }

    @Override
    public String toString() {
        return "Sale{" +
               "product='" + product + '\'' +
               ", category='" + category + '\'' +
               ", sales=" + sales +
               '}';
    }
}

// A class to hold the aggregated results for each category.
class CategorySalesSummary {
    double totalSales;
    double averageSales;
    long numberOfSales;

    // Constructor for the summary.
    public CategorySalesSummary(double totalSales, double averageSales, long numberOfSales) {
        this.totalSales = totalSales;
        this.averageSales = averageSales;
        this.numberOfSales = numberOfSales;
    }

    // Getters for accessing the summary fields.
    public double getTotalSales() {
        return totalSales;
    }

    public double getAverageSales() {
        return averageSales;
    }

    public long getNumberOfSales() {
        return numberOfSales;
    }

    @Override
    public String toString() {
        return "CategorySalesSummary{" +
               "totalSales=" + totalSales +
               ", averageSales=" + averageSales +
               ", numberOfSales=" + numberOfSales +
               '}';
    }
}

public class DataAggregationExample {

    public static void main(String[] args) {
        // This is our sample sales data, represented as a List of Sale objects.
        // In a real application, this data might come from a database or file.
        List<Sale> salesData = Arrays.asList(
                new Sale("Laptop", "Electronics", 1200.0),
                new Sale("Mouse", "Electronics", 25.0),
                new Sale("Keyboard", "Electronics", 75.0),
                new Sale("Monitor", "Electronics", 300.0),
                new Sale("Webcam", "Electronics", 50.0),
                new Sale("Desk", "Furniture", 150.0),
                new Sale("Chair", "Furniture", 80.0),
                new Sale("Lamp", "Furniture", 40.0)
        );

        // We use the Stream API to process our list of sales.
        // .stream() converts the list into a stream, allowing for functional operations.
        Map<String, CategorySalesSummary> aggregatedResults = salesData.stream()
                // The .collect() method is used to perform a mutable reduction operation
                // on the elements of the stream.
                // Collectors.groupingBy() is a powerful collector that groups elements
                // based on a classification function (here, by category).
                // The second argument to groupingBy is another collector that specifies
                // how to process the elements within each group.
                .collect(Collectors.groupingBy(
                        Sale::getCategory, // Classification function: group by the 'category' field.
                        // Downstream collector: this defines what we do with each group.
                        Collectors.reducing(
                                // Initial value for the reduction. We start with a zero summary.
                                new CategorySalesSummary(0.0, 0.0, 0L),
                                // Accumulator function: how to combine a Sale object with the current summary.
                                // We update total sales, sum sales for average, and increment count.
                                (sale, summary) -> new CategorySalesSummary(
                                        summary.totalSales + sale.getSales(),
                                        summary.averageSales + sale.getSales(), // We'll adjust average later
                                        summary.numberOfSales + 1
                                ),
                                // Combiner function: how to combine two intermediate summaries.
                                // This is used when processing in parallel, but also for combining results.
                                (summary1, summary2) -> new CategorySalesSummary(
                                        summary1.totalSales + summary2.totalSales,
                                        summary1.averageSales + summary2.averageSales, // Still accumulating for average
                                        summary1.numberOfSales + summary2.numberOfSales
                                )
                        )
                ));

        // After aggregation, we need to calculate the actual average sales for each category.
        // We iterate through the map of aggregated results.
        aggregatedResults.forEach((category, summary) -> {
            // Calculate the true average by dividing total sales by the number of sales.
            // We handle the case where numberOfSales might be zero to avoid division by zero errors.
            double average = (summary.numberOfSales > 0) ? summary.averageSales / summary.numberOfSales : 0.0;
            // Update the summary with the correct average.
            summary.averageSales = average;
        });

        // Print the aggregated results.
        // The map's keys are the categories, and the values are the CategorySalesSummary objects.
        System.out.println("--- Sales Analysis Results ---");
        aggregatedResults.forEach((category, summary) -> {
            System.out.println("Category: " + category);
            System.out.println("  Total Sales: " + summary.getTotalSales());
            System.out.println("  Average Sales: " + summary.getAverageSales());
            System.out.println("  Number of Sales: " + summary.getNumberOfSales());
        });

        System.out.println("\n--- Explanation of Results ---");
        System.out.println("The output shows aggregated sales data for each category:");
        System.out.println("- Total Sales: The sum of all sales for products within that category.");
        System.out.println("- Average Sales: The average sale value for products within that category.");
        System.out.println("- Number of Sales: The total number of individual sales transactions for that category.");
        System.out.println("This provides a quick overview of category performance.");
    }
}

// --- End of Tutorial ---